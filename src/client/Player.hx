package client;

import Types.PlayerType;
import Types.SkipSegment;
import Types.SkipSegmentType;
import Types.VideoData;
import Types.VideoDataRequest;
import Types.VideoItem;
import client.AnimeTranslationService;
import client.Main.getEl;
import client.players.Iframe;
import client.players.Peertube;
import client.players.Raw;
import client.players.Streamable;
import client.players.Twitch;
import client.players.Vk;
import client.players.Youtube;
import haxe.Http;
import haxe.Json;
import haxe.Timer;
import js.html.Audio;
import js.html.Element;
import js.html.InputElement;

class Player {
	final main:Main;
	final youtube:Youtube;
	final players:Array<IPlayer>;
	final iframePlayer:Iframe;
	final rawPlayer:Raw;
	final videoList = new VideoList();
	final videoItemsEl = getEl("#queue");
	final playerEl = getEl("#ytapiplayer");
	var player:Null<IPlayer>;
	var isLoaded = false;
	var skipSetTime = false;
	var skipSetRate = false;

	final voiceOverInput:InputElement = getEl("#voiceoverurl");
	var audioTrack:Null<Audio>;
	var isAudioTrackLoaded = false;
	var needsVolumeReset = false;
	final voiceOverVolume = 0.3;

	/** If player was clicked and pause/play event was not generated by browser events. **/
	public var inUserInteraction = false;

	public function new(main:Main):Void {
		this.main = main;
		youtube = new Youtube(main, this);
		players = [
			youtube,
			new Vk(main, this),
			new Streamable(main, this),
			new Peertube(main, this),
			new Twitch(main, this),
		];
		iframePlayer = new Iframe(main, this);
		rawPlayer = new Raw(main, this);
		initItemButtons();

		final resizeObserver = Utils.createResizeObserver(entries -> {
			if (isLoaded || videoList.length == 0) return;
			Buttons.onViewportResize();
		});
		if (resizeObserver != null) {
			resizeObserver.observe(playerEl);
		} else {
			final timer = new Timer(50);
			timer.run = () -> {
				if (isLoaded || videoList.length == 0) return;
				Buttons.onViewportResize();
			}
		}

		playerEl.addEventListener("click", e -> {
			inUserInteraction = true;
			// for some reason Chrome has ~300ms event delay
			Timer.delay(() -> inUserInteraction = false, 350);
		}, {});
	}

	function initItemButtons():Void {
		final queue = getEl("#queue");
		queue.onclick = e -> {
			final btn:Element = cast e.target;
			final item = btn.parentElement.parentElement;
			final i = Utils.getIndex(item.parentElement, item);
			if (btn.classList.contains("qbtn-play")) {
				main.send({
					type: PlayItem,
					playItem: {
						pos: i
					}
				});
			}
			if (btn.classList.contains("qbtn-next")) {
				main.send({
					type: SetNextItem,
					setNextItem: {
						pos: i
					}
				});
			}
			if (btn.classList.contains("qbtn-tmp")) {
				main.send({
					type: ToggleItemType,
					toggleItemType: {
						pos: i
					}
				});
			}
			if (btn.classList.contains("qbtn-delete")) {
				main.removeVideoItem(item.querySelector(".qe_title").getAttribute("href"));
			}
		}
	}

	public function setNextItem(pos:Int):Void {
		videoList.setNextItem(pos);

		final next = videoItemsEl.children[pos];
		videoItemsEl.removeChild(next);
		Utils.insertAtIndex(videoItemsEl, next, videoList.pos + 1);
	}

	public function toggleItemType(pos:Int):Void {
		videoList.toggleItemType(pos);
		final el = videoItemsEl.children[pos];
		setItemElementType(el, videoList.getItem(pos).isTemp);
	}

	public function getCurrentItem():Null<VideoItem> {
		return videoList.currentItem;
	}

	function setPlayer(newPlayer:IPlayer):Void {
		if (player != newPlayer) {
			if (player != null) {
				JsApi.fireVideoRemoveEvents(videoList.currentItem);
				player.removeVideo();
				removeExternalAudioTrack();
			}
			main.blinkTabWithTitle("*Video*");
		}
		player = newPlayer;
	}

	public function getVideoData(req:VideoDataRequest, callback:(data:VideoData) -> Void):Void {
		var player = players.find(player -> player.isSupportedLink(req.url));
		player ??= rawPlayer;
		player.getVideoData(req, data -> {
			data.playerType ??= player.getPlayerType();
			final voiceOverTrack = voiceOverInput.value.trim();
			voiceOverInput.value = "";
			data.voiceOverTrack ??= voiceOverTrack;
			callback(data);
		});
	}

	public function getPlayerType():Null<PlayerType> {
		if (player == null) return null;
		return player.getPlayerType();
	}

	public function getLinkPlayerType(url:String):PlayerType {
		final player = players.find(player -> player.isSupportedLink(url));
		if (player == null) return rawPlayer.getPlayerType();
		return player.getPlayerType();
	}

	public function isSingleVideoUrl(url:String):Bool {
		if (youtube.isSupportedLink(url)) {
			if (youtube.isPlaylistUrl(url)) return false;
		}
		if (~/, ?(https?)/g.match(url)) return false;
		if (main.urlMask.match(url)) return false;
		return true;
	}

	public function getIframeData(data:VideoDataRequest, callback:(data:VideoData) -> Void):Void {
		iframePlayer.getVideoData(data, data -> {
			data.playerType = IframeType;
			callback(data);
		});
	}

	public function setVideo(i:Int):Void {
		if (!main.isSyncActive) return;
		final item = videoList.getItem(i);
		setSupportedPlayer(item.url, item.playerType);

		removeActiveLabel(videoList.pos);
		videoList.setPos(i);
		addActiveLabel(videoList.pos);

		isLoaded = false;
		
		// Clear AniSkip cache when changing videos
		clearAniSkipCache();
		
		if (main.isVideoEnabled) {
			player.loadVideo(item);
			setExternalAudioTrack(item);
		} else {
			onCanBePlayed();
		}
		JsApi.fireVideoChangeEvents(item);
		getEl("#currenttitle").textContent = item.title;
	}

	function setExternalAudioTrack(item:VideoItem):Void {
		removeExternalAudioTrack();
		final voiceOverTrack = item.voiceOverTrack ?? return;
		if (voiceOverTrack.length == 0) return;
		audioTrack = new Audio(voiceOverTrack);
		if (!main.isAutoplayAllowed()) {
			audioTrack.muted = true;
		}
		inline function cleanAudioEvents() {
			audioTrack.oncanplay = null;
			audioTrack.onerror = null;
		}
		audioTrack.oncanplay = () -> {
			cleanAudioEvents();
			isAudioTrackLoaded = true;
		}
		audioTrack.onerror = e -> {
			trace(e);
			cleanAudioEvents();
			isAudioTrackLoaded = false;
			audioTrack = null;
			setVolume(1);
		}
	}

	function removeExternalAudioTrack():Void {
		isAudioTrackLoaded = false;
		needsVolumeReset = false;
		if (audioTrack == null) return;

		audioTrack?.pause();
		audioTrack.src = null;
		audioTrack = null;
		needsVolumeReset = true;
	}

	function setSupportedPlayer(url:String, playerType:PlayerType):Void {
		final currentPlayer = players.find(p -> p.isSupportedLink(url));
		if (currentPlayer != null) setPlayer(currentPlayer);
		else if (playerType == IframeType) setPlayer(iframePlayer);
		else if (playerType == TwitchType) setPlayer(players.find(p -> p.getPlayerType() == TwitchType));
		else setPlayer(rawPlayer);
	}

	public function changeVideoSrc(url:String):Void {
		if (!main.isVideoEnabled) return;
		final item:VideoItem = videoList.currentItem ?? return;
		setSupportedPlayer(url, item.playerType);
		player.loadVideo(item.withUrl(url));
	}

	public function removeVideo():Void {
		stopAutoSkipMonitoring(); // Stop auto-skip monitoring
		JsApi.fireVideoRemoveEvents(videoList.currentItem);
		player.removeVideo();
		getEl("#currenttitle").textContent = Lang.get("nothingPlaying");
		setPauseIndicator(false);
	}

	public function setPauseIndicator(isPause:Bool):Void {
		if (!main.isSyncActive) return;
		final state = isPause ? "pause" : "play";
		final el = getEl("#pause-indicator");
		el.setAttribute("name", state);

		final el2 = getEl("#pause-indicator-portrait");
		el2.setAttribute("name", state);
		var isVisible = isPause || main.hasLeader();
		el2.style.display = isVisible ? "" : "none";
	}

	public function onCanBePlayed():Void {
		if (!isLoaded) main.send({type: VideoLoaded});
		isLoaded = true;
		Buttons.onViewportResize();
		
		// Check for auto-skip segments when video is ready
		checkAutoSkipSegments();
	}

	function checkAutoSkipSegments():Void {
		trace('Checking auto-skip segments...');
		
		if (!main.getEnableAnimeSkip()) {
			trace('Anime skip is disabled in config');
			return;
		}
		
		final item = videoList.currentItem ?? return;
		trace('Current item: ${item.title} (isAnime: ${item.isAnime})');
		
		if (!isAnimeContent(item)) {
			trace('Item is not marked as anime content');
			return;
		}
		
		var autoSkipTypes:Array<SkipSegmentType> = [];
		
		if (main.getAutoSkipAnimeOpenings()) {
			autoSkipTypes.push(Opening);
			autoSkipTypes.push(Intro);
			trace('Auto-skip openings enabled');
		}
		
		if (main.getAutoSkipAnimeEndings()) {
			autoSkipTypes.push(Ending);
			autoSkipTypes.push(Outro);
			trace('Auto-skip endings enabled');
		}
		
		if (autoSkipTypes.length > 0) {
			trace('Starting auto-skip monitoring for: ${autoSkipTypes.map(t -> Std.string(t)).join(", ")}');
			startAutoSkipMonitoring(autoSkipTypes);
		} else {
			trace('No auto-skip types enabled');
		}
	}

	var autoSkipTimer:Null<haxe.Timer>;
	
	// AniSkip segment caching
	var aniSkipSegmentCache:Map<String, Array<SkipSegment>> = new Map();
	
	function getAniSkipCacheKey(animeInfo:{title:String, episode:Int}):String {
		return '${animeInfo.title}:${animeInfo.episode}';
	}
	
	function clearAniSkipCache():Void {
		var count = 0;
		for (key in aniSkipSegmentCache.keys()) count++;
		trace('Clearing AniSkip segment cache ($count entries)');
		aniSkipSegmentCache.clear();
		
		// Also clear the anime translation cache
		AnimeTranslationService.clearCache();
	}
	
	function startAutoSkipMonitoring(segmentTypes:Array<SkipSegmentType>):Void {
		stopAutoSkipMonitoring(); // Stop any existing timer
		
		autoSkipTimer = new haxe.Timer(1000); // Check every second
		autoSkipTimer.run = () -> {
			if (!isVideoLoaded() || videoList.currentItem == null) {
				stopAutoSkipMonitoring();
				return;
			}
			
			// Check if we should skip current segment
			skipSegments(segmentTypes);
		};
	}
	
	function stopAutoSkipMonitoring():Void {
		if (autoSkipTimer != null) {
			autoSkipTimer.stop();
			autoSkipTimer = null;
		}
	}

	public function onPlay():Void {
		audioTrack?.play();
		if (!isLoaded) return;
		if (!isSyncActive()) return;
		if (videoList.length == 0) return;

		final hasAutoPause = main.hasLeaderOnPauseRequest();
		if (!main.isLeader()) {
			// user click, so we can unpause by removing leader
			// (doesn't work in Firefox because of no video click propagation)
			var allowUnpause = hasAutoPause && inUserInteraction;
			if (!allowUnpause) allowUnpause = main.hasUnpauseWithoutLeader();
			// do not remove leader with custom rate
			if (getPlaybackRate() != 1) allowUnpause = false;
			if (allowUnpause) {
				main.removeLeader();
			} else {
				// paused and no leader - instant pause
				if (main.lastState.paused) {
					pause();
					main.blinkLeaderButton();
				}
			}
			return;
		}
		main.send({
			type: Play,
			play: {
				time: getTime()
			}
		});
		if (hasAutoPause) {
			// do not remove leader if user cannot request it back
			if (main.hasPermission(RequestLeaderPerm) && getPlaybackRate() == 1) {
				main.removeLeader();
			}
		}
	}

	public function onPause():Void {
		audioTrack?.pause();

		if (!isLoaded) return;
		if (!isSyncActive()) return;
		final item = videoList.currentItem ?? return;
		// do not send pause if video is ended
		if (getTime() >= item.duration - 0.01) return;
		var hasAutoPause = main.hasLeaderOnPauseRequest()
			&& videoList.length > 0
			&& getTime() > 1
			&& isLoaded;
		// do not set leader on pause if user tried to play server-paused video
		if (main.showingServerPause) hasAutoPause = false;
		// set leader and pause
		if (hasAutoPause && !main.hasLeader()) {
			JsApi.once(SetLeader, event -> {
				final name = event.setLeader.clientName;
				if (name != main.getName()) return;
				main.send({
					type: Pause,
					pause: {
						time: getTime()
					}
				});
				player.pause();
			});
			main.toggleLeader();
			return;
		}
		if (!main.isLeader()) {
			// no pause and no permission - instant play
			if (!main.lastState.paused) {
				play();
				main.blinkLeaderButton();
			}
			return;
		}
		// we are leader, so just send pause
		main.send({
			type: Pause,
			pause: {
				time: getTime()
			}
		});
	}

	public function onSetTime():Void {
		if (audioTrack != null) {
			audioTrack.currentTime = getTime();
		}

		if (skipSetTime) {
			skipSetTime = false;
			return;
		}
		if (videoList.length == 0) return;
		if (!main.isLeader()) {
			if (main.hasLeader() || main.lastState.pausedByServer) {
				final off = isPaused() ? 0 : main.timeFromLastState;
				final time = main.lastState.time;
				final delta = Math.abs(time - getTime());
				setTime(time);
				main.blinkLeaderButton();
			} else {
				// we dont want to seek back here because
				// after seek can happen pause that will give auto-leader,
				// so seeking will work
			}
			return;
		}
		main.send({
			type: SetTime,
			setTime: {
				time: getTime()
			}
		});
	}

	public function onRateChange():Void {
		if (audioTrack != null) {
			audioTrack.playbackRate = getPlaybackRate();
		}
		if (skipSetRate) {
			skipSetRate = false;
			return;
		}
		if (videoList.length == 0) return;
		if (!main.isLeader()) {
			main.blinkLeaderButton();
			return;
		}
		main.send({
			type: SetRate,
			setRate: {
				rate: getPlaybackRate()
			}
		});
	}

	public function addVideoItem(item:VideoItem, atEnd:Bool):Void {
		final url = item.url.htmlEscape(true);
		final duration = item.playerType == IframeType ? "" : duration(item.duration);
		final itemEl = Utils.nodeFromString(
			'<li class="queue_entry info" title="${Lang.get("addedBy")}: ${item.author}">
				<header>
					<span class="qe_time">$duration</span>
					<h4><a class="qe_title" href="$url" target="_blank">${item.title.htmlEscape()}</a></h4>
				</header>
				<span class="controls">
					<button class="qbtn-play" title="${Lang.get("play")}"><ion-icon name="play"></ion-icon></button>
					<button class="qbtn-next" title="${Lang.get("setNext")}"><ion-icon name="arrow-up"></ion-icon></button>
					<button class="qbtn-tmp"><ion-icon></ion-icon></button>
					<button class="qbtn-delete" title="${Lang.get("delete")}"><ion-icon name="close"></ion-icon></button>
				</span>
			</li>'
		);
		videoList.addItem(item, atEnd);
		setItemElementType(itemEl, item.isTemp);
		if (atEnd) videoItemsEl.appendChild(itemEl);
		else Utils.insertAtIndex(videoItemsEl, itemEl, videoList.pos + 1);
		updateCounters();
	}

	function setItemElementType(item:Element, isTemp:Bool):Void {
		final btn = item.querySelector(".qbtn-tmp");
		btn.title = isTemp ? Lang.get("makePermanent") : Lang.get("makeTemporary");
		final iconType = isTemp ? "lock-open" : "lock-closed";
		btn.firstElementChild.setAttribute("name", iconType);
		item.classList.toggle("queue_temp", isTemp);
	}

	public function removeItem(url:String):Void {
		removeElementItem(url);
		// Try to find by exact URL match first
		var index = videoList.findIndex(item -> item.url == url);
		
		// If not found and it's a YouTube URL or iframe HTML with YouTube embed, try to match by video ID
		if (index == -1) {
			var videoId = "";
			// Handle case where url is regular YouTube URL
			if (url.indexOf("youtube.com") > -1 || url.indexOf("youtu.be") > -1) {
				videoId = youtube.extractVideoId(url);
			}
			// Handle case where url is an iframe HTML string
			else if (url.indexOf("<iframe") > -1 && url.indexOf("youtube.com/embed/") > -1) {
				final embedMatch = ~/youtube\.com\/embed\/([A-z0-9_-]+)/g;
				if (embedMatch.match(url)) {
					videoId = embedMatch.matched(1);
				}
			}
			
			if (videoId != "") {
				index = videoList.findIndex(item -> {
					// Check if this is a regular YouTube URL
					if (item.url.indexOf("youtube.com") > -1 || item.url.indexOf("youtu.be") > -1) {
						return youtube.extractVideoId(item.url) == videoId;
					}
					// Check if this is an iframe embedded YouTube live stream
					else if (item.playerType == IframeType && 
						item.url.indexOf("<iframe") > -1 && 
						item.url.indexOf("youtube.com/embed/") > -1) {
						return item.url.indexOf(videoId) > -1;
					}
					return false;
				});
			}
		}
		
		if (index == -1) return;

		final isCurrent = videoList.currentItem.url == videoList.getItem(index).url;
		videoList.removeItem(index);
		updateCounters();

		if (isCurrent && videoList.length > 0) {
			setVideo(videoList.pos);
		}
	}

	function removeElementItem(url:String):Void {
		var videoId = "";
		// Extract video ID if it's a YouTube URL
		if (url.indexOf("youtube.com") > -1 || url.indexOf("youtu.be") > -1) {
			videoId = youtube.extractVideoId(url);
		}
		// Extract video ID if it's an iframe HTML string
		else if (url.indexOf("<iframe") > -1 && url.indexOf("youtube.com/embed/") > -1) {
			final embedMatch = ~/youtube\.com\/embed\/([A-z0-9_-]+)/g;
			if (embedMatch.match(url)) {
				videoId = embedMatch.matched(1);
			}
		}
		
		for (child in videoItemsEl.children) {
			final href = child.querySelector(".qe_title").getAttribute("href");
			
			// Check if regular URL matches
			if (href == url) {
				videoItemsEl.removeChild(child);
				break;
			}
			
			// If we have a valid YouTube video ID, try to match by that
			if (videoId != "") {
				// Check if href is a YouTube URL
				if (href.indexOf("youtube.com") > -1 || href.indexOf("youtu.be") > -1) {
					final hrefVideoId = youtube.extractVideoId(href);
					if (hrefVideoId == videoId) {
						videoItemsEl.removeChild(child);
						break;
					}
				}
				// Check if href is an iframe embed
				else if (href.indexOf("<iframe") > -1 && href.indexOf("youtube.com/embed/") > -1) {
					if (href.indexOf(videoId) > -1) {
						videoItemsEl.removeChild(child);
						break;
					}
				}
			}
		}
	}

	public function skipItem(url:String):Void {
		final pos = videoList.findIndex(item -> item.url == url);
		if (pos == -1) return;
		removeActiveLabel(videoList.pos);
		videoList.setPos(pos);
		if (videoList.currentItem.isTemp) removeElementItem(url);
		videoList.skipItem();
		updateCounters();
		if (videoList.length == 0) return;
		setVideo(videoList.pos);
	}

	function addActiveLabel(pos:Int):Void {
		final childs = videoItemsEl.children;
		if (childs[videoList.pos] != null) {
			childs[videoList.pos].classList.add("queue_active");
		}
	}

	function removeActiveLabel(pos:Int):Void {
		final childs = videoItemsEl.children;
		if (childs[videoList.pos] != null) {
			childs[videoList.pos].classList.remove("queue_active");
		}
	}

	function updateCounters():Void {
		getEl("#plcount").textContent = '${videoList.length} ${Lang.get("videos")}';
		getEl("#pllength").textContent = totalDuration();
	}

	public function getItems():Array<VideoItem> {
		return videoList.getItems();
	}

	public function setItems(list:Array<VideoItem>, ?pos:Int):Void {
		final currentUrl = videoList.pos >= videoList.length ? "" : videoList.currentItem.url;
		clearItems();
		if (list.length == 0) return;
		for (video in list) {
			addVideoItem(video, true);
		}
		if (pos != null) videoList.setPos(pos);
		if (currentUrl != videoList.currentItem.url) setVideo(videoList.pos);
		else addActiveLabel(videoList.pos);
	}

	public function clearItems():Void {
		videoList.clear();
		videoItemsEl.textContent = "";
		updateCounters();
	}

	public function refresh():Void {
		if (videoList.length == 0) return;
		final time = getTime();
		removeVideo();
		setVideo(videoList.pos);
		// restore server time for leader with next GetTime
		if (main.isLeader()) {
			setTime(time);
			main.forceSyncNextTick = true;
		}
	}

	function duration(time:Float):String {
		final h = Std.int(time / 60 / 60);
		final m = Std.int(time / 60) - h * 60;
		final s = Std.int(time % 60);
		var time = '$m:';
		if (m < 10) time = '0$time';
		if (h > 0) time = '$h:$time';
		if (s < 10) time = time + "0";
		time += s;
		return time;
	}

	function totalDuration():String {
		var time = 0.0;
		for (item in videoList.getItems()) {
			if (item.playerType == IframeType) continue;
			time += item.duration;
		}
		return duration(time);
	}

	public function isListEmpty():Bool {
		return videoList.length == 0;
	}

	public function itemsLength():Int {
		return videoList.length;
	}

	public function getItemPos():Int {
		return videoList.pos;
	}

	public function hasVideo():Bool {
		return playerEl.children.length != 0;
	}

	public function getDuration():Float {
		if (videoList.pos >= videoList.length) return 0;
		return videoList.currentItem.duration;
	}

	public function isVideoLoaded():Bool {
		if (player == null) return false;
		return player.isVideoLoaded();
	}

	function isSyncActive():Bool {
		if (!main.isSyncActive) return false;
		final item = videoList.currentItem ?? return false;
		return item.playerType != IframeType;
	}

	public function play():Void {
		if (!isSyncActive()) return;
		if (player == null) return;
		if (!player.isVideoLoaded()) return;
		player.play();
		if (needsVolumeReset) setVolume(1);

		if (audioTrack != null) {
			setVolume(0.3);
			audioTrack?.play();
		}
	}

	public function pause():Void {
		if (!isSyncActive()) return;
		if (player == null) return;
		if (!player.isVideoLoaded()) return;
		player.pause();

		audioTrack?.pause();
	}

	public function getTime():Float {
		if (player == null) return 0;
		if (!player.isVideoLoaded()) return 0;
		return player.getTime();
	}

	public function setTime(time:Float, isLocal = true):Void {
		if (!isSyncActive()) return;
		if (player == null) return;
		if (!player.isVideoLoaded()) return;
		skipSetTime = isLocal;
		player.setTime(time);

		if (audioTrack != null) audioTrack.currentTime = time;
	}

	public function getPlaybackRate():Float {
		if (player == null) return 1;
		if (!player.isVideoLoaded()) return 1;
		return player.getPlaybackRate();
	}

	public function setPlaybackRate(rate:Float, isLocal = true):Void {
		if (!isSyncActive()) return;
		if (player == null) return;
		if (!player.isVideoLoaded()) return;
		skipSetRate = isLocal;
		player.setPlaybackRate(rate);

		if (audioTrack != null) audioTrack.playbackRate = rate;
	}

	public function skipAd():Void {
		skipSegments([Sponsor]);
	}

	public function skipAnimeOpening():Void {
		skipSegments([Opening, Intro]);
	}

	public function skipAnimeEnding():Void {
		skipSegments([Ending, Outro]);
	}

	public function skipAnimeSegments():Void {
		skipSegments([Opening, Ending, Intro, Outro, Recap]);
	}

	function skipSegments(segmentTypes:Array<SkipSegmentType>):Void {
		final item = videoList.currentItem ?? return;
		var itemUrl = item.url;
		
		// First try SponsorBlock for sponsor segments
		if (segmentTypes.contains(Sponsor)) {
			skipSponsorBlockSegments(itemUrl);
		}
		
		// Then try AniSkip for anime segments if enabled
		final animeTypes = segmentTypes.filter(type -> type != Sponsor);
		if (animeTypes.length > 0 && main.getEnableAnimeSkip() && isAnimeContent(item)) {
			skipAniSkipSegments(itemUrl, animeTypes);
		}
	}

	function skipSponsorBlockSegments(itemUrl:String):Void {
		if (!youtube.isSupportedLink(itemUrl)) {
			itemUrl = itemUrl.replace("/cache/", "youtu.be/");
			if (!youtube.isSupportedLink(itemUrl)) return;
		}
		final id = youtube.extractVideoId(itemUrl);
		final url = 'https://sponsor.ajay.app/api/skipSegments?videoID=$id';
		final http = new Http(url);
		http.onData = text -> {
			final json:Array<{segment:Array<Float>}> = try {
				Json.parse(text);
			} catch (e) {
				return;
			}
			for (block in json) {
				final start = block.segment[0];
				final end = block.segment[1];
				final time = getTime();
				if (time > start - 1 && time < end) {
					main.send({
						type: Rewind,
						rewind: {
							time: end - time - 1
						}
					});
					return; // Skip only first matching segment
				}
			}
		}
		http.onError = msg -> trace(msg);
		http.request();
	}

	function skipAniSkipSegments(itemUrl:String, segmentTypes:Array<SkipSegmentType>):Void {
		final item = videoList.currentItem;
		if (item == null) return;
		
		// Extract anime title and episode info for AniSkip lookup
		final animeInfo = extractAnimeInfo(item.title);
		if (animeInfo.title == "") {
			trace('Could not extract anime info from title: ${item.title}');
			return;
		}
		
		// Get title variations for better AniSkip database compatibility (if enabled)
		if (main.getEnableAnimeTitleTranslation()) {
			trace('Getting title variations for anime title: "${animeInfo.title}"');
			AnimeTranslationService.getTitleVariations(animeInfo.title, (primaryTitle:String, variations:Array<String>) -> {
				handleAniSkipWithVariations(animeInfo, primaryTitle, variations, segmentTypes);
			});
		} else {
			trace('Anime title translation is disabled, using original title: "${animeInfo.title}"');
			handleAniSkipWithVariations(animeInfo, animeInfo.title, [animeInfo.title], segmentTypes);
		}
	}
	
	function handleAniSkipWithVariations(animeInfo:{title:String, episode:Int}, primaryTitle:String, variations:Array<String>, segmentTypes:Array<SkipSegmentType>):Void {
		// Try each title variation until we find skip segments
		tryAniSkipWithVariations(animeInfo, primaryTitle, variations, segmentTypes, 0);
	}
	
	function tryAniSkipWithVariations(animeInfo:{title:String, episode:Int}, primaryTitle:String, variations:Array<String>, segmentTypes:Array<SkipSegmentType>, varIndex:Int):Void {
		if (varIndex >= variations.length) {
			trace('No skip segments found with any title variation');
			return;
		}
		
		final currentTitle = variations[varIndex];
		final currentAnimeInfo = {
			title: currentTitle,
			episode: animeInfo.episode
		};
		
		final cacheKey = getAniSkipCacheKey(currentAnimeInfo);
		
		// Check cache first
		if (aniSkipSegmentCache.exists(cacheKey)) {
			final cachedSegments = aniSkipSegmentCache.get(cacheKey);
			trace('Cache hit for: ${currentTitle} episode ${animeInfo.episode} (${cachedSegments.length} segments)');
			processSkipSegments(cachedSegments, segmentTypes);
			return;
		}
		
		trace('Trying AniSkip query ${varIndex + 1}/${variations.length}: "${currentTitle}" episode ${animeInfo.episode}');
		
		// Query AniSkip API with current title variation
		queryAniSkipAPI(currentAnimeInfo, segmentTypes, (segments:Array<SkipSegment>) -> {
			// Cache the results
			aniSkipSegmentCache.set(cacheKey, segments);
			
			if (segments.length > 0) {
				trace('Success! Found ${segments.length} segments with title: "${currentTitle}"');
				
				// Cache under primary title and original title too for future lookups
				if (currentTitle != primaryTitle) {
					final primaryCacheKey = getAniSkipCacheKey({title: primaryTitle, episode: animeInfo.episode});
					aniSkipSegmentCache.set(primaryCacheKey, segments);
				}
				if (currentTitle != animeInfo.title) {
					final originalCacheKey = getAniSkipCacheKey(animeInfo);
					aniSkipSegmentCache.set(originalCacheKey, segments);
				}
				
				processSkipSegments(segments, segmentTypes);
			} else {
				trace('No segments found with "${currentTitle}", trying next variation...');
				// Try next variation
				tryAniSkipWithVariations(animeInfo, primaryTitle, variations, segmentTypes, varIndex + 1);
			}
		});
	}
	
	function processSkipSegments(segments:Array<SkipSegment>, segmentTypes:Array<SkipSegmentType>):Void {
		final currentTime = getTime();
		trace('Current video time: ${currentTime}s, checking ${segments.length} segments');
		
		for (segment in segments) {
			// Only process segments of requested types
			if (!segmentTypes.contains(segment.type)) continue;
			
			if (currentTime >= segment.start - 1 && currentTime <= segment.end) {
				trace('Skipping ${segment.type} segment: ${segment.start}-${segment.end}');
				main.send({
					type: Rewind,
					rewind: {
						time: segment.end - currentTime
					}
				});
				return; // Skip only first matching segment
			}
		}
		
		trace('No segments match current time ${currentTime}s');
	}

	function extractAnimeInfo(title:String):{title:String, episode:Int} {
		// Try to extract anime title and episode number from video title
		var cleanTitle = title;
		var episode = 1;
		
		trace('Original title: "$title"');
		
		// STEP 1: Try to extract episode number from original title first (before aggressive cleanup)
		final episodePatterns = [
			~/\s+episode\s+(\d+)/i,                    // " Episode 12"
			~/\s+ep\.?\s*(\d+)/i,                      // " Ep 12" or " Ep. 12"
			~/\s+e(\d+)(?:\s|$)/i,                     // " E12 "
			~/\s*-\s*(\d+)\s*\[/,                      // "- 04 [" (common in release names)
			~/\s+(\d+)\s*\[.*?\]\s*$/,                 // " 04 [tags]" at end
			~/\s+(\d+)(?:\s*-\s*\d+)?\s*$/,            // " 12" or " 12-13" at end
			~/\s*-\s*(\d+)(?:\s*-\s*\d+)?\s*$/,        // "- 12" or "- 12-13" at end
			~/s(\d+)e(\d+)/i,                          // "S1E12" - capture episode as second group
			~/season\s*\d+\s+episode\s+(\d+)/i,        // "Season 1 Episode 12"
			~/\s+(\d+)(?:話|화)(?:\s|$)/,               // Japanese/Korean episode markers
		];
		
		// Try episode extraction on original title first
		var patternMatched = false;
		for (i in 0...episodePatterns.length) {
			final pattern = episodePatterns[i];
			if (pattern.match(title)) {
				trace('Pattern ${i} matched original title');
				patternMatched = true;
				// Special handling for S#E# pattern (episode is second group)
				if (i == 7) { // s(\d+)e(\d+) pattern - index updated
					episode = Std.parseInt(pattern.matched(2));
					trace('Extracted episode from S#E# pattern: ${pattern.matched(2)}');
				} else {
					episode = Std.parseInt(pattern.matched(1));
					trace('Extracted episode from pattern: ${pattern.matched(1)}');
				}
				
				if (episode == null || episode <= 0) episode = 1;
				trace('Found episode $episode using pattern ${i}');
				break;
			}
		}
		
		if (!patternMatched) {
			trace('No episode patterns matched original title: "$title"');
		}
		
		// STEP 2: Clean up the title for anime name extraction
		cleanTitle = ~/\.(mp4|mkv|avi|webm|m4v)$/i.replace(cleanTitle, ""); // Remove file extensions
		cleanTitle = ~/\s*(1080p|720p|480p|HD|SD|BluRay|WEB-DL|WEBRip|x264|x265|HEVC).*$/i.replace(cleanTitle, ""); // Remove quality tags
		cleanTitle = ~/\s*\[.*?\]/g.replace(cleanTitle, ""); // Remove [tags] like [SubGroup]
		cleanTitle = ~/\s*\(.*?\)/g.replace(cleanTitle, ""); // Remove (tags) like (Eng Sub)
		
		// Remove episode numbers and common patterns from title
		cleanTitle = ~/\s*-\s*\d+\s*$/g.replace(cleanTitle, ""); // Remove "- 04" at end
		cleanTitle = ~/\s+episode\s+\d+.*$/i.replace(cleanTitle, ""); // Remove "Episode 04" and after
		cleanTitle = ~/\s+ep\.?\s*\d+.*$/i.replace(cleanTitle, ""); // Remove "Ep 04" and after
		cleanTitle = ~/\s+e\d+.*$/i.replace(cleanTitle, ""); // Remove "E04" and after
		cleanTitle = ~/\s*-\s*(END|FINAL)?\s*$/i.replace(cleanTitle, ""); // Remove trailing dash
		
		// Final cleanup
		cleanTitle = ~/^\s*-\s*/.replace(cleanTitle, ""); // Remove leading dash
		cleanTitle = ~/\s*-\s*$/.replace(cleanTitle, ""); // Remove trailing dash
		cleanTitle = ~/\s+/g.replace(cleanTitle, " "); // Normalize spaces
		cleanTitle = StringTools.trim(cleanTitle);
		
		trace('After title cleanup: "$cleanTitle"');
		
		// Handle common edge cases
		if (cleanTitle == "" || cleanTitle.length < 2) {
			cleanTitle = title; // Fallback to original if cleaning went wrong
			episode = 1;
			trace('Title cleanup failed, using original title');
		}
		
		// Normalize common anime title variations AFTER episode extraction
		final normalizedTitle = normalizeAnimeTitle(cleanTitle);
		
		trace('Final extracted: title="$normalizedTitle", episode=$episode');
		
		return {title: normalizedTitle, episode: episode};
	}

	function normalizeAnimeTitle(title:String):String {
		// Common anime title normalizations
		final titleMappings = new Map<String, String>();
		
		// Popular anime title variations (Japanese -> English)
		titleMappings.set("Kaijuu 8 Gou", "Kaiju No. 8");
		titleMappings.set("Kaijuu 8-gou", "Kaiju No. 8");
		titleMappings.set("Monster #8", "Kaiju No. 8");
		titleMappings.set("Shingeki no Kyojin", "Attack on Titan");
		titleMappings.set("Kimetsu no Yaiba", "Demon Slayer");
		titleMappings.set("Kimetsu no Yaiba: Demon Slayer", "Demon Slayer");
		titleMappings.set("Jujutsu Kaisen", "Jujutsu Kaisen");
		titleMappings.set("Boku no Hero Academia", "My Hero Academia");
		titleMappings.set("Bokutachi no Remake", "Remake Our Life!");
		titleMappings.set("One Punch Man", "One-Punch Man");
		titleMappings.set("Dr. Stone", "Dr. STONE");
		titleMappings.set("Spy x Family", "SPY×FAMILY");
		titleMappings.set("Chainsaw Man", "Chainsaw Man");
		titleMappings.set("Mob Psycho 100", "Mob Psycho 100");
		titleMappings.set("Tokyo Ghoul", "Tokyo Ghoul");
		titleMappings.set("Naruto", "Naruto");
		titleMappings.set("One Piece", "One Piece");
		titleMappings.set("Bleach", "Bleach");
		
		// Korean title variations
		titleMappings.set("신의 탑", "Tower of God");
		titleMappings.set("갓 오브 하이스쿨", "The God of High School");
		titleMappings.set("노블레스", "Noblesse");
		
		// Alternative English spellings/formats
		titleMappings.set("Attack On Titan", "Attack on Titan");
		titleMappings.set("My Hero Academia", "My Hero Academia");
		titleMappings.set("Hunter X Hunter", "Hunter x Hunter");
		titleMappings.set("JoJo's Bizarre Adventure", "JoJo's Bizarre Adventure");
		titleMappings.set("Fullmetal Alchemist", "Fullmetal Alchemist");
		titleMappings.set("Death Note", "Death Note");
		titleMappings.set("One-Piece", "One Piece");
		titleMappings.set("DragonBall", "Dragon Ball");
		titleMappings.set("Dragon Ball Z", "Dragon Ball Z");
		titleMappings.set("Cowboy Bebop", "Cowboy Bebop");
		
		// Check for exact matches first
		if (titleMappings.exists(title)) {
			final normalized = titleMappings.get(title);
			trace('Title normalized: "$title" → "$normalized"');
			return normalized;
		}
		
		// Check for partial matches (case insensitive)
		final lowerTitle = title.toLowerCase();
		for (key in titleMappings.keys()) {
			if (lowerTitle.indexOf(key.toLowerCase()) != -1) {
				final normalized = titleMappings.get(key);
				trace('Title normalized (partial): "$title" → "$normalized"');
				return normalized;
			}
		}
		
		// Common patterns to normalize
		var normalized = title;
		
		// Normalize numbering styles
		normalized = ~/\bNo\.\s*(\d+)/.replace(normalized, "No. $1"); // "No.8" → "No. 8"
		normalized = ~/\b(\d+)-gou\b/i.replace(normalized, "No. $1"); // "8-gou" → "No. 8"
		normalized = ~/\b#(\d+)\b/.replace(normalized, "No. $1"); // "#8" → "No. 8"
		
		// Normalize spacing and punctuation
		normalized = ~/\s+x\s+/.replace(normalized, "×"); // " x " → "×"
		normalized = ~/\bDr\.\s*/i.replace(normalized, "Dr. "); // "Dr." normalization
		
		if (normalized != title) {
			trace('Title normalized (pattern): "$title" → "$normalized"');
		}
		
		return normalized;
	}

	function queryAniSkipAPI(animeInfo:{title:String, episode:Int}, segmentTypes:Array<SkipSegmentType>, callback:Array<SkipSegment>->Void):Void {
		trace('Starting AniSkip API query chain for "${animeInfo.title}" episode ${animeInfo.episode}');
		trace('Request types: ${segmentTypes.map(t -> Std.string(t)).join(", ")}');
		
		// Step 1: Search for shows
		searchAniSkipShows(animeInfo.title, (shows:Array<Dynamic>) -> {
			if (shows.length == 0) {
				trace('No shows found for "${animeInfo.title}"');
				callback([]);
				return;
			}
			
			// Find the best matching show
			var bestShow:Dynamic = shows[0]; // Default to first result
			for (show in shows) {
				final showName:String = show.name;
				if (showName != null && showName.toLowerCase().indexOf(animeInfo.title.toLowerCase()) != -1) {
					bestShow = show;
					break;
				}
			}
			
			trace('Selected show: ${bestShow.name} (ID: ${bestShow.id})');
			
			// Step 2: Get episodes for the selected show
			getAniSkipEpisodes(bestShow.id, (episodes:Array<Dynamic>) -> {
				if (episodes.length == 0) {
					trace('No episodes found for show ID ${bestShow.id}');
					callback([]);
					return;
				}
				
				// Find the matching episode
				var targetEpisode:Dynamic = null;
				for (episode in episodes) {
					if (episode.number == animeInfo.episode) {
						targetEpisode = episode;
						break;
					}
				}
				
				if (targetEpisode == null) {
					trace('Episode ${animeInfo.episode} not found in ${episodes.length} available episodes');
					callback([]);
					return;
				}
				
				trace('Found episode ${targetEpisode.number} (ID: ${targetEpisode.id})');
				
				// Step 3: Get timestamps for the episode
				getAniSkipTimestamps(targetEpisode.id, segmentTypes, callback);
			});
		});
	}

	function searchAniSkipShows(animeName:String, callback:Array<Dynamic>->Void):Void {
		final query = {
			query: 'query SearchShows($$search: String!, $$limit: Int) {
				searchShows(search: $$search, limit: $$limit) {
					id
					name
					createdAt
				}
			}',
			variables: {
				search: animeName,
				limit: 10
			}
		};
		
		executeAniSkipQuery(query, (data:Dynamic) -> {
			if (data == null) {
				trace('AniSkip API error: null response for show search');
				callback([]);
				return;
			}
			
			if (data.searchShows != null) {
				final shows:Array<Dynamic> = data.searchShows;
				trace('Found ${shows.length} shows for "${animeName}"');
				for (show in shows) {
					trace('  - ${show.name} (${show.id})');
				}
				callback(shows);
			} else {
				trace('No shows found in response for "${animeName}"');
				callback([]);
			}
		});
	}

	function getAniSkipEpisodes(showId:String, callback:Array<Dynamic>->Void):Void {
		final query = {
			query: 'query FindEpisodesByShowId($$showId: ID!) {
				findEpisodesByShowId(showId: $$showId) {
					id
					number
					name
					createdAt
				}
			}',
			variables: {
				showId: showId
			}
		};
		
		executeAniSkipQuery(query, (data:Dynamic) -> {
			if (data == null) {
				trace('AniSkip API error: null response for episodes search');
				callback([]);
				return;
			}
			
			if (data.findEpisodesByShowId != null) {
				final episodes:Array<Dynamic> = data.findEpisodesByShowId;
				trace('Found ${episodes.length} episodes for show ${showId}');
				callback(episodes);
			} else {
				trace('No episodes found in response for show ${showId}');
				callback([]);
			}
		});
	}

	function getAniSkipTimestamps(episodeId:String, segmentTypes:Array<SkipSegmentType>, callback:Array<SkipSegment>->Void):Void {
		final query = {
			query: 'query FindTimestampsByEpisodeId($$episodeId: ID!) {
				findTimestampsByEpisodeId(episodeId: $$episodeId) {
					id
					at
					typeId
					createdAt
				}
			}',
			variables: {
				episodeId: episodeId
			}
		};
		
		executeAniSkipQuery(query, (data:Dynamic) -> {
			if (data == null) {
				trace('AniSkip API error: null response for timestamps search');
				callback([]);
				return;
			}
			
			if (data.findTimestampsByEpisodeId != null) {
				final timestamps:Array<Dynamic> = data.findTimestampsByEpisodeId;
				trace('Found ${timestamps.length} timestamps for episode ${episodeId}');
				
				// Convert timestamps to SkipSegments
				final segments:Array<SkipSegment> = [];
				
				// Group timestamps by type and sort by time
				final timestampsByType = new Map<String, Array<Dynamic>>();
				for (timestamp in timestamps) {
					trace('Processing timestamp: ${Json.stringify(timestamp)}');
					// Validate timestamp data
					if (timestamp.typeId == null || timestamp.at == null) {
						trace('Skipping invalid timestamp: ${Json.stringify(timestamp)}');
						continue;
					}
					
					final typeId:String = timestamp.typeId;
					final at:Float = timestamp.at;
					
					// Skip negative timestamps
					if (at < 0) {
						trace('Skipping negative timestamp: ${at}s');
						continue;
					}
					
					if (!timestampsByType.exists(typeId)) {
						timestampsByType.set(typeId, []);
					}
					timestampsByType.get(typeId).push(timestamp);
					trace('Added timestamp to type ${typeId}: ${at}s');
				}
				
				// Process each type to create segments
				for (typeId => typeTimestamps in timestampsByType) {
					if (typeTimestamps == null || typeTimestamps.length == 0) {
						continue;
					}
					
					// Sort timestamps by time
					typeTimestamps.sort((a, b) -> {
						return (a.at < b.at) ? -1 : (a.at > b.at) ? 1 : 0;
					});
					
					// Convert typeId to SkipSegmentType
					// Map known AniSkip UUID types to our SkipSegmentType enum
					final segmentType = switch (typeId) {
						// Real AniSkip API type UUIDs (updated from actual API responses):
						case "9edc0037-fa4e-47a7-a29a-d9c43368daa8": Opening; // Opening credits (confirmed)
						case "c7b1eddb-defa-4bc6-a598-f143081cfe4b": Ending;  // Ending credits (from logs)
						case "f38ac196-0d49-40a9-8fcf-f3ef2f40f127": Intro;   // Intro/recap (from logs)
						case "14550023-2589-46f0-bfb4-152976506b4c": Outro;   // Outro/preview (from logs)
						case "2a730a51-a601-439b-bc1f-7b94a640ffb9": Recap;   // Recap segment (from logs)
						
						// Legacy UUIDs (keep for backward compatibility)
						case "67321535-a4ea-4f21-8bed-fb3c8286b510": Ending;  // Legacy ending
						case "742d3889-2b60-4e17-958a-1e31b3a6e5b5": Intro;   // Legacy intro
						case "f58634aa-f866-44f3-9e67-1d5d5c6b5e1c": Outro;   // Legacy outro
						
						default: {
							trace('Unknown segment type UUID: ${typeId} - treating as generic segment');
							// Don't skip unknown types, treat them as generic openings for now
							Opening;
						}
					};
					
					trace('Processing segment type ${segmentType} (typeId: ${typeId})');
					
					// Check if this segment type is requested
					if (!segmentTypes.contains(segmentType)) {
						trace('Segment type ${segmentType} not requested, skipping');
						continue;
					}
					
					// Create segments from timestamps
					if (typeTimestamps.length == 0) continue;
					
					if (typeTimestamps.length >= 2) {
						// Multiple timestamps: try to pair them
						var i = 0;
						while (i < typeTimestamps.length - 1) {
							final startTime:Float = typeTimestamps[i].at;
							final endTime:Float = typeTimestamps[i + 1].at;
							
							// Only create segment if end time is after start time and duration is reasonable
							if (endTime > startTime && (endTime - startTime) >= 5.0 && (endTime - startTime) < 600) { // Min 5s, Max 10 minutes
								segments.push({
									start: startTime,
									end: endTime,
									type: segmentType
								});
								trace('Created ${segmentType} segment: ${startTime}s - ${endTime}s (paired, duration: ${endTime - startTime}s)');
								i += 2; // Skip to next pair
							} else {
								// If pairing fails, treat as single timestamp
								final duration = getDefaultDuration(segmentType);
								segments.push({
									start: startTime,
									end: startTime + duration,
									type: segmentType
								});
								trace('Created ${segmentType} segment: ${startTime}s - ${startTime + duration}s (single + default duration)');
								i += 1;
							}
						}
						
						// Handle odd remaining timestamp
						if (i < typeTimestamps.length) {
							final startTime:Float = typeTimestamps[i].at;
							final duration = getDefaultDuration(segmentType);
							segments.push({
								start: startTime,
								end: startTime + duration,
								type: segmentType
							});
							trace('Created ${segmentType} segment: ${startTime}s - ${startTime + duration}s (single remaining)');
						}
					} else {
						// Single timestamp: use default duration
						final startTime:Float = typeTimestamps[0].at;
						final duration = getDefaultDuration(segmentType);
						segments.push({
							start: startTime,
							end: startTime + duration,
							type: segmentType
						});
						trace('Created ${segmentType} segment: ${startTime}s - ${startTime + duration}s (single + default duration)');
					}
				}
				
				// Sort segments by start time and remove any overlaps
				segments.sort((a, b) -> {
					return (a.start < b.start) ? -1 : (a.start > b.start) ? 1 : 0;
				});
				
				// Log final segment summary
				trace('Created ${segments.length} skip segments total:');
				for (segment in segments) {
					trace('  ${segment.type}: ${segment.start}s - ${segment.end}s (${segment.end - segment.start}s)');
				}
				
				callback(segments);
			} else {
				trace('No timestamps found in response for episode ${episodeId}');
				callback([]);
			}
		});
	}

	function getDefaultDuration(segmentType:SkipSegmentType):Float {
		return switch (segmentType) {
			case Opening: 90.0;  // Typical anime opening is 90 seconds
			case Ending: 90.0;   // Typical anime ending is 90 seconds
			case Intro: 30.0;    // Intro/recap segments are usually shorter
			case Outro: 30.0;    // Preview/next episode segments
			case Recap: 60.0;    // Recap segments can be longer
			default: 90.0;       // Default to 90 seconds
		}
	}
	
	function executeAniSkipQuery(query:Dynamic, callback:Dynamic->Void):Void {
		final http = new Http("https://api.anime-skip.com/graphql");
		http.addHeader("Content-Type", "application/json");
		
		final apiKey = main.getAnimeSkipApiKey();
		if (apiKey != "") {
			http.addHeader("X-Client-ID", apiKey);
		} else {
			http.addHeader("X-Client-ID", "tuubi-sync");
		}
		
		http.setPostData(Json.stringify(query));
		
		http.onData = text -> {
			try {
				final response:Dynamic = Json.parse(text);
				
				if (response.errors != null) {
					final errors:Array<Dynamic> = response.errors;
					var isAuthError = false;
					for (error in errors) {
						final message:String = error.message ?? "";
						trace('AniSkip GraphQL error: ${message}');
						
						// Check for authentication-related errors
						if (message.toLowerCase().indexOf("unauthorized") != -1 ||
							message.toLowerCase().indexOf("forbidden") != -1 ||
							message.toLowerCase().indexOf("client") != -1) {
							isAuthError = true;
						}
					}
					
					if (isAuthError) {
						trace('AniSkip authentication error - check X-Client-ID header and API key configuration');
					}
					
					callback(null);
					return;
				}
				
				if (response.data != null) {
					callback(response.data);
				} else {
					trace('No data in AniSkip response');
					callback(null);
				}
				
			} catch (e:Dynamic) {
				trace('Error parsing AniSkip JSON response: $e');
				trace('Raw response text: $text');
				callback(null);
			}
		};
		
		http.onError = msg -> {
			trace('AniSkip API HTTP error: $msg');
			// Check for common HTTP error codes that indicate authentication issues
			if (msg.indexOf("401") != -1) {
				trace('AniSkip authentication failed (401) - verify X-Client-ID header');
			} else if (msg.indexOf("403") != -1) {
				trace('AniSkip access forbidden (403) - check API key permissions');
			} else if (msg.indexOf("404") != -1) {
				trace('AniSkip endpoint not found (404) - verify API URL');
			}
			callback(null);
		};
		
		http.request();
	}

	function buildAniSkipGraphQLQuery(animeName:String, episode:Int, segmentTypes:Array<SkipSegmentType>):{query:String, variables:Dynamic} {
		// Step 1: Search for shows by name
		return {
			query: 'query SearchShows($$search: String!, $$limit: Int) {
				searchShows(search: $$search, limit: $$limit) {
					id
					name
					createdAt
				}
			}',
			variables: {
				search: animeName,
				limit: 10
			}
		};
	}

	function parseAniSkipGraphQLResponse(data:Dynamic, requestedTypes:Array<SkipSegmentType>):Array<SkipSegment> {
		final segments:Array<SkipSegment> = [];
		
		// Handle introspection response
		if (data.__schema != null) {
			trace('=== AniSkip GraphQL Schema Discovery ===');
			final schema = data.__schema;
			if (schema.queryType != null && schema.queryType.fields != null) {
				final fields:Array<Dynamic> = schema.queryType.fields;
				trace('Available root query fields:');
				for (field in fields) {
					trace('  - ${field.name}: ${field.type?.name ?? field.type?.kind}');
					if (field.args != null && field.args.length > 0) {
						final args:Array<Dynamic> = field.args;
						trace('    Args: ${args.map(arg -> '${arg.name}(${arg.type?.name ?? arg.type?.kind})').join(", ")}');
					}
				}
			}
			trace('=== End Schema Discovery ===');
			return segments; // Return empty for introspection
		}
		
		// Handle actual search response (will implement after discovering schema)
		if (data == null) {
			trace('No data in response');
			return segments;
		}
		
		trace('Response data keys: ${Reflect.fields(data).join(", ")}');
		
		return segments;
	}

	function mapAniSkipGraphQLType(graphqlType:String):SkipSegmentType {
		return switch (graphqlType.toUpperCase()) {
			case "OP" | "OPENING": Opening;
			case "ED" | "ENDING": Ending;
			case "INTRO": Intro;
			case "OUTRO": Outro;
			case "RECAP": Recap;
			default: Opening; // Default fallback
		}
	}


	function isAnimeContent(item:VideoItem):Bool {
		// Use the explicit anime flag from the checkbox
		return item.isAnime;
	}

	public function isPaused():Bool {
		if (player == null) return true;
		if (!player.isVideoLoaded()) return true;
		return player.isPaused();
	}

	public function getVolume():Float {
		if (player == null) return 1;
		if (!player.isVideoLoaded()) return 1;
		return player.getVolume();
	}

	public function setVolume(volume:Float):Void {
		if (player == null) return;
		if (!player.isVideoLoaded()) return;
		player.setVolume(volume);
	}

	public function unmute():Void {
		if (player == null) return;
		if (!player.isVideoLoaded()) return;
		player.unmute();
		if (audioTrack != null) audioTrack.muted = false;
		if (audioTrack == null && almostEq(getVolume(), voiceOverVolume, 0.01)) {
			setVolume(1);
		}
	}

	function almostEq(a:Float, b:Float, diff:Float):Bool {
		return a > b - diff && a < b + diff;
	}

	/**
	 * Public method to extract YouTube video ID from URL
	 * This prevents direct access to the private youtube property
	 */
	public function extractYoutubeVideoId(url:String):String {
		return youtube.extractVideoId(url);
	}

	/**
	 * Public method to search YouTube videos
	 * This prevents direct access to the private youtube property
	 */
	public function searchYoutubeVideos(query:String, maxResults:Int = 20, callback:(videoIds:Array<String>) -> Void, ?customApiKey:String, ?userName:String, ?isRandomVideo:Bool):Void {
		youtube.searchVideos(query, maxResults, callback, customApiKey, userName, isRandomVideo);
	}
}
