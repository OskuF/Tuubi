<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SyncTube Chat</title>
  <link rel="icon" href="img/favicon.svg" type="image/svg+xml">
  <script type="module" src="https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.esm.js"></script>
  <script nomodule="" src="https://cdn.jsdelivr.net/npm/ionicons@7.4.0/dist/ionicons/ionicons.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a1a;
      color: #ffffff;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .chat-header {
      background: #2d2d2d;
      padding: 8px 12px;
      border-bottom: 1px solid #404040;
      display: flex;
      justify-content: between;
      align-items: center;
      flex-shrink: 0;
    }

    .chat-title {
      font-size: 14px;
      font-weight: bold;
      flex: 1;
    }

    .close-btn {
      background: #ff4444;
      border: none;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .close-btn:hover {
      background: #ff6666;
    }

    #messagebuffer {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
      display: flex;
      flex-direction: column-reverse;
      background: #1a1a1a;
    }

    #chatbox {
      display: flex;
      padding: 8px;
      background: #2d2d2d;
      border-top: 1px solid #404040;
      gap: 4px;
      flex-shrink: 0;
    }

    #chatline {
      flex: 1;
      background: #404040;
      border: 1px solid #555;
      color: #ffffff;
      padding: 8px;
      border-radius: 4px;
      font-size: 14px;
    }

    #chatline:focus {
      outline: none;
      border-color: #007acc;
    }

    #chatbox button {
      background: #404040;
      border: 1px solid #555;
      color: #ffffff;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #chatbox button:hover {
      background: #555;
    }

    #danmaku-label {
      display: flex;
      align-items: center;
      font-size: 12px;
      white-space: nowrap;
      cursor: pointer;
    }

    #send-as-danmaku {
      margin-right: 4px;
    }

    .message {
      padding: 4px 0;
      border-bottom: 1px solid #2d2d2d;
      word-wrap: break-word;
    }

    .message:last-child {
      border-bottom: none;
    }

    .message .username {
      font-weight: bold;
      margin-right: 8px;
    }

    .message.server {
      color: #888;
      font-style: italic;
    }

    .emote-panels {
      background: #2d2d2d;
      border-top: 1px solid #404040;
      height: 320px;
      overflow: visible;
      display: none;
    }

    .emote-panel {
      padding: 8px;
      height: 100%;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .emote-search {
      width: 100%;
      background: #404040;
      border: 1px solid #555;
      color: white;
      padding: 4px;
      border-radius: 4px;
      margin-bottom: 6px;
      flex-shrink: 0;
    }

    .emote-grid-container {
      position: relative;
      height: 280px;
      flex-shrink: 0;
    }

    .emote-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
      gap: 4px;
      height: 100%;
      align-content: start;
      overflow-y: auto;
    }

    .loading-indicator {
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(45, 45, 45, 0.95);
      padding: 8px 12px;
      border-radius: 4px;
      border: 1px solid #555;
      color: white;
      font-size: 12px;
      z-index: 10;
    }

    .emote {
      width: 40px;
      height: 40px;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .emote:hover {
      background: #404040;
    }

    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: #2d2d2d;
    }

    ::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #777;
    }

    .spin {
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    .emote-inline {
      height: 128px;
      width: auto;
      vertical-align: middle;
    }

    /* Danmaku container styling */
    #danmaku-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 1000;
      overflow: hidden;
    }

    .danmaku-message {
      position: absolute;
      white-space: nowrap;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      pointer-events: none;
      z-index: 1001;
      animation: danmaku-scroll 8s linear;
      color: white;
    }

    @keyframes danmaku-scroll {
      0% {
        transform: translateX(100vw);
        opacity: 1;
      }
      100% {
        transform: translateX(-100vw);
        opacity: 0;
      }
    }

    /* Danmaku emote animations */
    @keyframes danmaku-glow {
      0%, 100% { filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.8)); }
      50% { filter: drop-shadow(0 0 20px rgba(255, 255, 255, 1)); }
    }
    .danmaku-emote-glow img, .danmaku-emote-glow video {
      animation: danmaku-glow 2s ease-in-out infinite;
    }

    @keyframes danmaku-shake {
      0%, 100% { transform: translateY(0); }
      25% { transform: translateY(-10px); }
      50% { transform: translateY(0); }
      75% { transform: translateY(10px); }
    }
    .danmaku-emote-shake img, .danmaku-emote-shake video {
      animation: danmaku-shake 0.5s ease-in-out infinite;
    }

    @keyframes danmaku-spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .danmaku-emote-spin img, .danmaku-emote-spin video {
      animation: danmaku-spin 2s linear infinite;
      transform-origin: center;
    }

    @keyframes danmaku-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }
    .danmaku-emote-pulse img, .danmaku-emote-pulse video {
      animation: danmaku-pulse 1s ease-in-out infinite;
      transform-origin: center;
    }

    @keyframes danmaku-bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-20px); }
      60% { transform: translateY(-10px); }
    }
    .danmaku-emote-bounce img, .danmaku-emote-bounce video {
      animation: danmaku-bounce 2s ease infinite;
    }

    @keyframes danmaku-rainbow {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }
    .danmaku-emote-rainbow img, .danmaku-emote-rainbow video {
      animation: danmaku-rainbow 3s linear infinite;
    }

    @keyframes danmaku-flip {
      0%, 100% { transform: rotateY(0deg); }
      50% { transform: rotateY(180deg); }
    }
    .danmaku-emote-flip img, .danmaku-emote-flip video {
      animation: danmaku-flip 2s ease infinite;
      transform-style: preserve-3d;
    }

    @keyframes danmaku-hover {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-15px); }
    }
    .danmaku-emote-hover img, .danmaku-emote-hover video {
      animation: danmaku-hover 3s ease-in-out infinite;
    }

    @keyframes danmaku-heartbeat {
      0%, 100% { transform: scale(1); }
      15% { transform: scale(1.3); }
      30% { transform: scale(1); }
      45% { transform: scale(1.3); }
    }
    .danmaku-emote-heartbeat img, .danmaku-emote-heartbeat video {
      animation: danmaku-heartbeat 1.5s ease-in-out infinite;
      transform-origin: center;
    }

    @keyframes danmaku-wobble {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(-15deg); }
      50% { transform: rotate(0deg); }
      75% { transform: rotate(15deg); }
    }
    .danmaku-emote-wobble img, .danmaku-emote-wobble video {
      animation: danmaku-wobble 0.8s ease-in-out infinite;
      transform-origin: center bottom;
    }

    @keyframes danmaku-blur {
      0%, 100% { filter: blur(0); }
      50% { filter: blur(4px); }
    }
    .danmaku-emote-blur img, .danmaku-emote-blur video {
      animation: danmaku-blur 2s ease-in-out infinite;
    }

    @keyframes danmaku-glitch {
      0%, 100% { transform: translate(0); }
      20% { transform: translate(-5px, 5px); }
      40% { transform: translate(-5px, -5px); }
      60% { transform: translate(5px, 5px); }
      80% { transform: translate(5px, -5px); }
    }
    .danmaku-emote-glitch img, .danmaku-emote-glitch video {
      animation: danmaku-glitch 0.3s linear infinite;
    }

    @keyframes danmaku-swing {
      0%, 100% { transform: rotate(10deg); }
      50% { transform: rotate(-10deg); }
    }
    .danmaku-emote-swing img, .danmaku-emote-swing video {
      animation: danmaku-swing 1s ease-in-out infinite;
      transform-origin: center top;
    }

    @keyframes danmaku-trampoline {
      0%, 100% { transform: scaleY(1) translateY(0); }
      40% { transform: scaleY(0.8) translateY(10px); }
      60% { transform: scaleY(1.2) translateY(-30px); }
    }
    .danmaku-emote-trampoline img, .danmaku-emote-trampoline video {
      animation: danmaku-trampoline 2s cubic-bezier(.5, 0.05, 1, .5) infinite;
      transform-origin: bottom center;
    }

    @keyframes danmaku-neon {
      0%, 100% { filter: drop-shadow(0 0 5px cyan) drop-shadow(0 0 10px rgba(0, 255, 255, 0.8)); }
      50% { filter: drop-shadow(0 0 10px magenta) drop-shadow(0 0 15px rgba(255, 0, 255, 0.8)); }
    }
    .danmaku-emote-neon img, .danmaku-emote-neon video {
      animation: danmaku-neon 2s ease-in-out infinite;
    }

    @keyframes danmaku-fade {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    .danmaku-emote-fade img, .danmaku-emote-fade video {
      animation: danmaku-fade 2s ease-in-out infinite;
    }

    .danmaku-emote-container {
      background: transparent;
      border-radius: 0.5rem;
      padding: 0.25rem 0.5rem;
    }
  </style>
</head>

<body>
  <div id="danmaku-container" style="display: none;"></div>
  
  <div class="chat-header">
    <div class="chat-title">External Chat</div>
    <button class="close-btn" onclick="window.close()">×</button>
  </div>

  <div id="messagebuffer"></div>

  <div class="emote-panels">
    <div id="smiles-wrap" class="emote-panel" style="display: none;">
      <input id="smiles-search" class="emote-search" type="text" placeholder="Search emotes...">
      <div class="emote-grid-container">
        <div id="smiles-list" class="emote-grid"></div>
        <div id="smiles-loading" class="loading-indicator" style="display: none;">
          <ion-icon name="refresh" class="spin"></ion-icon> Loading...
        </div>
      </div>
    </div>
    <div id="ffz-wrap" class="emote-panel" style="display: none;">
      <input id="ffz-search" class="emote-search" type="text" placeholder="Search FrankerFaceZ emotes...">
      <div class="emote-grid-container">
        <div id="ffz-list" class="emote-grid"></div>
        <div id="ffz-loading" class="loading-indicator" style="display: none;">
          <ion-icon name="refresh" class="spin"></ion-icon> Loading...
        </div>
      </div>
    </div>
    <div id="seventv-wrap" class="emote-panel" style="display: none;">
      <input id="seventv-search" class="emote-search" type="text" placeholder="Search 7TV emotes...">
      <div class="emote-grid-container">
        <div id="seventv-list" class="emote-grid"></div>
        <div id="seventv-loading" class="loading-indicator" style="display: none;">
          <ion-icon name="refresh" class="spin"></ion-icon> Loading...
        </div>
      </div>
    </div>
  </div>

  <div id="chatbox">
    <input id="chatline" type="text" placeholder="Type a message...">
    <label id="danmaku-label" title="Send as danmaku comment">
      <input id="send-as-danmaku" type="checkbox">
      <span>Danmaku</span>
    </label>
    <button id="smilesbtn" title="Emotes">
      <ion-icon name="happy"></ion-icon>
    </button>
    <button id="ffzbtn" title="FrankerFaceZ Emotes">
      <svg class="ffz-logo" xmlns="http://www.w3.org/2000/svg" width="20" height="15" viewBox="0 0 40 30">
        <path d="M0 0 C2.16047869 2.4250271 3.58587233 5.08993562 5 8 C5.33 8.66 5.66 9.32 6 10 C6.66 9.01 7.32 8.02 8 7 C10.25 7 10.25 7 13 8 C15.52766881 11.38368444 16.75848001 15.07107696 17.8125 19.125 C16.62879885 23.31348099 14.07849513 24.57003098 10.43359375 26.7421875 C4.58966365 29.76264575 -1.48501 31.04875449 -8 30 C-11.55782242 28.66913051 -14.74677826 26.94966599 -18 25 C-19.546875 24.13375 -19.546875 24.13375 -21.125 23.25 C-23.64940917 20.22070899 -23.57854088 18.04986793 -23.375 14.1953125 C-22.88257477 11.31257311 -21.78042787 9.29971934 -20 7 C-17.625 7.25 -17.625 7.25 -15 8 C-13.8359375 10.046875 -13.8359375 10.046875 -13 12 C-12.81824219 11.30132812 -12.63648438 10.60265625 -12.44921875 9.8828125 C-12.19785156 8.97273437 -11.94648438 8.06265625 -11.6875 7.125 C-11.44386719 6.22007812 -11.20023438 5.31515625 -10.94921875 4.3828125 C-8.9221256 -0.70577523 -4.85725817 -0.83745831 0 0 Z " fill="#FFFFFF" transform="translate(23,0)"/>
      </svg>
    </button>
    <button id="seventvbtn" title="7TV Emotes">
      <svg class="seventv-logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 27 20" width="20" height="15">
        <g fill="#FFFFFF">
          <path
            d="M20.7465 5.48825L21.9799 3.33745L22.646 2.20024L21.4125 0.0494437V0H14.8259L17.2928 4.3016L17.9836 5.48825H20.7465Z" />
          <path
            d="M7.15395 19.9258L14.5546 7.02104L15.4673 5.43884L13.0004 1.13724L12.3097 0.0247596H1.8995L0.666057 2.17556L0 3.31276L1.23344 5.46356V5.51301H9.12745L2.96025 16.267L2.09685 17.7998L3.33029 19.9506V20H7.15395" />
          <path
            d="M17.4655 19.9257H21.2398L26.1736 11.3225L27.037 9.83924L25.8036 7.68844V7.63899H22.0046L19.5377 11.9406L19.365 12.262L16.8981 7.96038L16.7255 7.63899L14.2586 11.9406L13.5679 13.1272L17.2682 19.5796L17.4655 19.9257Z" />
        </g>
      </svg>
    </button>
  </div>

  <script>
    // This will be populated by the parent window
    window.parentMain = null;
    window.chatPopout = true;

    // Command handling system (copied from main chat)
    window.availableCommands = [
      { name: "help", description: "Show list of available commands", usage: "/help", requiresLeader: false },
      { name: "ban", description: "Ban a user for specified time", usage: "/ban <username> <time>", requiresLeader: true },
      { name: "unban", description: "Remove ban from a user", usage: "/unban <username>", requiresLeader: true },
      { name: "kick", description: "Kick a user from the room", usage: "/kick <username>", requiresLeader: true },
      { name: "clear", description: "Clear chat messages", usage: "/clear", requiresLeader: true },
      { name: "flashback", description: "Show flashback", usage: "/flashback", requiresLeader: false },
      { name: "fb", description: "Show flashback (short for flashback)", usage: "/fb", requiresLeader: false },
      { name: "ad", description: "Skip current ad", usage: "/ad", requiresLeader: false },
      { name: "random", description: "Get random FrankerFaceZ emote", usage: "/random", requiresLeader: false },
      { name: "random7tv", description: "Get random 7TV emote", usage: "/random7tv", requiresLeader: false },
      { name: "volume", description: "Set volume level (0.0 to 3.0)", usage: "/volume <level>", requiresLeader: false },
      { name: "dump", description: "Dump current state information", usage: "/dump", requiresLeader: true },
      { name: "skip", description: "Skip forward by seconds", usage: "/skip [seconds]", requiresLeader: false }
    ];

    // Current autocomplete state
    window.commandAutocomplete = {
      visible: false,
      selectedIndex: -1,
      filteredCommands: [],
      menuElement: null
    };

    // Danmaku emote animations function (shared with main chat)
    window.getDanmakuRandomAnimation = function() {
      // This will be populated by the parent window or use fallback
      if (window.parentMain && window.parentMain.getDanmakuRandomAnimation) {
        return window.parentMain.getDanmakuRandomAnimation();
      }
      
      // Fallback implementation matching the main chat logic
      const animations = [
        "danmaku-emote-glow",
        "danmaku-emote-shake", 
        "danmaku-emote-spin",
        "danmaku-emote-pulse",
        "danmaku-emote-bounce",
        "danmaku-emote-rainbow",
        "danmaku-emote-flip",
        "danmaku-emote-hover",
        "danmaku-emote-heartbeat",
        "danmaku-emote-wobble",
        "danmaku-emote-blur",
        "danmaku-emote-glitch",
        "danmaku-emote-swing",
        "danmaku-emote-trampoline",
        "danmaku-emote-neon",
        "danmaku-emote-fade"
      ];
      
      // 20% chance of no animation
      if (Math.random() < 0.2) return "";
      
      // Select a random animation from the list
      const index = Math.floor(Math.random() * animations.length);
      return animations[index];
    };

    // State management for infinite scrolling
    window.emoteState = {
      ffz: { currentPage: 1, isLoading: false, hasMore: true, autoLoadDepth: 0, lastLoadTime: 0 },
      seventv: { currentPage: 1, isLoading: false, hasMore: true, autoLoadDepth: 0, lastLoadTime: 0 }
    };

    // Debug connection status
    function debugConnection() {
      console.log('=== Popout Connection Debug ===');
      console.log('window.parentMain:', window.parentMain);
      console.log('window.opener:', window.opener);
      console.log('window.opener.closed:', window.opener ? window.opener.closed : 'N/A');

      if (window.parentMain) {
        console.log('parentMain.sendChatMessage exists:', typeof window.parentMain.sendChatMessage === 'function');
      }

      if (window.opener && !window.opener.closed) {
        console.log('window.opener.Main exists:', !!window.opener.Main);
        console.log('window.opener.Main.instance exists:', !!(window.opener.Main && window.opener.Main.instance));
      }
    }

    // Try to establish connection with parent
    function establishParentConnection() {
      console.log('Attempting to establish parent connection...');

      // Method 1: Use the parentMain that should be set by parent
      if (window.parentMain && typeof window.parentMain.sendChatMessage === 'function') {
        console.log('✓ Connection established via parentMain');
        console.log('parentMain type:', typeof window.parentMain);
        console.log('sendChatMessage type:', typeof window.parentMain.sendChatMessage);
        return true;
      }

      // Method 2: Try to use window.opener directly
      if (window.opener && !window.opener.closed) {
        try {
          // Try to access the Main instance through the opener
          if (window.opener.Main && window.opener.Main.instance) {
            const mainInstance = window.opener.Main.instance;
            console.log('Found Main.instance:', mainInstance);
            console.log('sendChatMessage exists:', typeof mainInstance.sendChatMessage);

            if (typeof mainInstance.sendChatMessage === 'function') {
              window.parentMain = mainInstance;
              console.log('✓ Connection established via window.opener.Main.instance');
              return true;
            } else {
              console.log('✗ sendChatMessage is not a function on Main.instance');
            }
          } else {
            console.log('✗ window.opener.Main.instance not found');
          }
        } catch (e) {
          console.log('✗ Failed to access window.opener.Main:', e);
        }
      }

      // Method 3: Try to get the instance directly from opener window
      if (window.opener && !window.opener.closed) {
        try {
          // Look for any global variables that might contain the Main instance
          console.log('Checking opener window for Main references...');
          console.log('opener keys:', Object.keys(window.opener).filter(k => k.includes('Main') || k.includes('main')));

          // Try to find the instance in various ways
          const possibleMains = [
            window.opener.Main?.instance,
            window.opener.main,
            window.opener._mainInstance,
            window.opener.synctube?.main
          ];

          for (const candidate of possibleMains) {
            if (candidate && typeof candidate.sendChatMessage === 'function') {
              window.parentMain = candidate;
              console.log('✓ Connection established via alternative method');
              return true;
            }
          }
        } catch (e) {
          console.log('✗ Alternative method failed:', e);
        }
      }

      console.log('✗ Failed to establish parent connection');
      return false;
    }

    // Command autocomplete functionality
    function createAutocompleteMenu() {
      if (window.commandAutocomplete.menuElement) return;
      
      const menu = document.createElement('div');
      menu.className = 'command-autocomplete-menu';
      menu.style.cssText = `
        position: absolute;
        background-color: #2d2d2d;
        border: 1px solid #555;
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        max-height: 200px;
        overflow-y: auto;
        z-index: 1000;
        min-width: 300px;
        display: none;
      `;
      
      document.body.appendChild(menu);
      window.commandAutocomplete.menuElement = menu;
    }

    function getFilteredCommands(filter) {
      const isLeader = window.parentMain && window.parentMain.isLeader && window.parentMain.isLeader();
      let filtered = window.availableCommands.slice();
      
      // Filter by leader permission if not leader
      if (!isLeader) {
        filtered = filtered.filter(cmd => !cmd.requiresLeader);
      }
      
      // Filter by name match
      if (filter.length > 0) {
        const filterLower = filter.toLowerCase();
        filtered = filtered.filter(cmd => cmd.name.toLowerCase().includes(filterLower));
      }
      
      return filtered;
    }

    function showAutocompleteMenu(query) {
      const filtered = getFilteredCommands(query);
      
      if (filtered.length === 0) {
        hideAutocompleteMenu();
        return;
      }
      
      window.commandAutocomplete.filteredCommands = filtered;
      window.commandAutocomplete.selectedIndex = -1;
      
      renderAutocompleteMenu();
      positionAutocompleteMenu();
      
      window.commandAutocomplete.visible = true;
      window.commandAutocomplete.menuElement.style.display = 'block';
    }

    function hideAutocompleteMenu() {
      window.commandAutocomplete.visible = false;
      window.commandAutocomplete.selectedIndex = -1;
      if (window.commandAutocomplete.menuElement) {
        window.commandAutocomplete.menuElement.style.display = 'none';
      }
    }

    function renderAutocompleteMenu() {
      const menu = window.commandAutocomplete.menuElement;
      const commands = window.commandAutocomplete.filteredCommands;
      menu.innerHTML = '';
      
      commands.forEach((command, index) => {
        const item = document.createElement('div');
        item.className = 'command-autocomplete-item';
        item.style.cssText = `
          padding: 8px 12px;
          cursor: pointer;
          border-bottom: 1px solid #404040;
          color: #ffffff;
        `;
        
        // Command name
        const nameDiv = document.createElement('div');
        nameDiv.style.cssText = `
          font-weight: bold;
          color: ${command.requiresLeader ? '#ffb800' : '#ffffff'};
        `;
        nameDiv.textContent = command.usage;
        
        // Description
        const descDiv = document.createElement('div');
        descDiv.style.cssText = `
          font-size: 12px;
          color: #bbb;
          margin-top: 2px;
        `;
        descDiv.textContent = command.description;
        
        item.appendChild(nameDiv);
        item.appendChild(descDiv);
        
        // Add leader requirement indicator
        const isLeader = window.parentMain && window.parentMain.isLeader && window.parentMain.isLeader();
        if (command.requiresLeader && !isLeader) {
          const leaderIndicator = document.createElement('span');
          leaderIndicator.style.cssText = `
            color: #ff6666;
            font-size: 11px;
            font-style: italic;
            margin-top: 2px;
            display: block;
          `;
          leaderIndicator.textContent = 'Requires leader permission';
          item.appendChild(leaderIndicator);
        }
        
        // Add click handler
        item.addEventListener('click', () => selectCommand(index));
        
        // Add hover effects
        item.addEventListener('mouseenter', () => {
          window.commandAutocomplete.selectedIndex = index;
          updateAutocompleteSelection(false); // Don't scroll on mouse hover
        });
        
        menu.appendChild(item);
      });
      
      updateAutocompleteSelection();
    }

    function positionAutocompleteMenu() {
      const chatline = document.getElementById('chatline');
      const menu = window.commandAutocomplete.menuElement;
      const inputRect = chatline.getBoundingClientRect();
      const viewportHeight = window.innerHeight;
      
      // Calculate available space
      const spaceBelow = viewportHeight - inputRect.bottom;
      const spaceAbove = inputRect.top;
      
      // More realistic menu height estimation: ~50px per item + padding, max 200px
      const commands = window.commandAutocomplete.filteredCommands;
      const itemHeight = 50; // More realistic item height including padding/borders
      const estimatedMenuHeight = Math.min(200, Math.max(60, commands.length * itemHeight + 16)); // +16 for container padding
      
      // Positioning logic: Position above if either:
      // 1. Not enough space below AND enough space above, OR
      // 2. Not enough space below AND more space above than below
      const enoughSpaceBelow = spaceBelow >= estimatedMenuHeight;
      const enoughSpaceAbove = spaceAbove >= estimatedMenuHeight;
      
      const shouldPositionAbove = !enoughSpaceBelow && (enoughSpaceAbove || spaceAbove > spaceBelow);
      
      if (shouldPositionAbove) {
        // Position above the input
        const topPosition = Math.max(5, inputRect.top - estimatedMenuHeight - 2); // Ensure at least 5px from viewport top
        menu.style.top = topPosition + 'px';
      } else {
        // Position below the input
        menu.style.top = (inputRect.bottom + 2) + 'px';
      }
      
      menu.style.left = inputRect.left + 'px';
    }

    function updateAutocompleteSelection(shouldScroll = false) {
      const items = window.commandAutocomplete.menuElement.querySelectorAll('.command-autocomplete-item');
      items.forEach((item, index) => {
        if (index === window.commandAutocomplete.selectedIndex) {
          item.style.backgroundColor = '#404040';
        } else {
          item.style.backgroundColor = 'transparent';
        }
      });
      
      // Only scroll when explicitly requested (keyboard navigation, not mouse hover)
      if (shouldScroll && window.commandAutocomplete.selectedIndex >= 0 && window.commandAutocomplete.selectedIndex < items.length) {
        const selectedItem = items[window.commandAutocomplete.selectedIndex];
        selectedItem.scrollIntoView({ block: 'nearest' });
      }
    }

    function selectCommand(index) {
      const commands = window.commandAutocomplete.filteredCommands;
      if (index >= 0 && index < commands.length) {
        const command = commands[index];
        const chatline = document.getElementById('chatline');
        
        // Insert command into input
        chatline.value = command.usage.split(' ')[0];
        
        // Position cursor at end
        chatline.setSelectionRange(chatline.value.length, chatline.value.length);
        chatline.focus();
        
        hideAutocompleteMenu();
      }
    }

    function navigateAutocomplete(direction) {
      const commands = window.commandAutocomplete.filteredCommands;
      if (commands.length === 0) return;
      
      if (direction === 'up') {
        window.commandAutocomplete.selectedIndex--;
        if (window.commandAutocomplete.selectedIndex < 0) {
          window.commandAutocomplete.selectedIndex = commands.length - 1;
        }
      } else if (direction === 'down') {
        window.commandAutocomplete.selectedIndex++;
        if (window.commandAutocomplete.selectedIndex >= commands.length) {
          window.commandAutocomplete.selectedIndex = 0;
        }
      }
      
      updateAutocompleteSelection(true); // Scroll for keyboard navigation
    }

    // Command processing function
    function processCommand(commandText) {
      if (!commandText.startsWith('/')) return false;
      
      const args = commandText.trim().split(' ');
      const command = args[0].substring(1).toLowerCase();
      
      // Commands that can be handled locally in popout
      switch (command) {
        case 'help':
          showCommandHelp();
          return true;
        case 'clear':
          clearPopoutChat();
          return true;
        default:
          // Forward to parent window for processing
          if (window.parentMain && window.parentMain.handleCommands) {
            return window.parentMain.handleCommands(commandText);
          }
          return false;
      }
    }

    function showCommandHelp() {
      const isLeader = window.parentMain && window.parentMain.isLeader && window.parentMain.isLeader();
      const availableCommands = window.availableCommands.filter(cmd => !cmd.requiresLeader || isLeader);
      
      let helpText = '<div style="color: #888; font-style: italic;">Available commands:</div>';
      availableCommands.forEach(cmd => {
        const color = cmd.requiresLeader ? '#ffb800' : '#ffffff';
        helpText += `<div style="color: ${color}; margin: 2px 0;"><strong>${cmd.usage}</strong> - ${cmd.description}</div>`;
      });
      
      addMessage(helpText);
    }

    function clearPopoutChat() {
      const messagebuffer = document.getElementById('messagebuffer');
      if (messagebuffer) {
        messagebuffer.innerHTML = '';
      }
    }

    // Initialize basic chat functionality for popout
    function initializePopoutChat() {
      const chatline = document.getElementById('chatline');
      const smilesbtn = document.getElementById('smilesbtn');
      const ffzbtn = document.getElementById('ffzbtn');
      const seventvbtn = document.getElementById('seventvbtn');

      // Handle enter key for sending messages
      if (chatline) {
        // Create autocomplete menu
        createAutocompleteMenu();
        
        chatline.addEventListener('input', function(e) {
          const value = this.value;
          if (value.startsWith('/')) {
            const query = value.substring(1);
            showAutocompleteMenu(query);
          } else {
            hideAutocompleteMenu();
          }
        });
        
        chatline.addEventListener('keydown', function (e) {
          // Handle autocomplete navigation
          if (window.commandAutocomplete.visible) {
            switch (e.key) {
              case 'ArrowUp':
                e.preventDefault();
                navigateAutocomplete('up');
                return;
              case 'ArrowDown':
                e.preventDefault();
                navigateAutocomplete('down');
                return;
              case 'Enter':
                if (window.commandAutocomplete.selectedIndex >= 0) {
                  e.preventDefault();
                  selectCommand(window.commandAutocomplete.selectedIndex);
                  return;
                }
                break;
              case 'Escape':
                e.preventDefault();
                hideAutocompleteMenu();
                return;
            }
          }
          
          if (e.key === 'Enter') {
            e.preventDefault();
            const message = this.value.trim();
            if (message) {
              // Check if it's a command
              if (message.startsWith('/')) {
                const commandHandled = processCommand(message);
                if (commandHandled) {
                  this.value = '';
                  return;
                }
                
                // If command wasn't handled locally, try to send to parent
                if (!establishParentConnection()) {
                  debugConnection();
                  alert('Error: Cannot process command - connection to main window lost\n\nPlease close this popout window and open it again.');
                  return;
                }
                
                try {
                  if (window.parentMain.handleCommands && window.parentMain.handleCommands(message)) {
                    this.value = '';
                    return;
                  }
                } catch (error) {
                  console.error('Error processing command:', error);
                }
              }
              
              // Try to establish/re-establish connection if needed
              if (!establishParentConnection()) {
                debugConnection();
                alert('Error: Cannot send message - connection to main window lost\n\nPlease close this popout window and open it again.');
                return;
              }

              try {
                const isDanmaku = document.getElementById('send-as-danmaku').checked;
                console.log('Sending message from popout:', message, 'isDanmaku:', isDanmaku);
                window.parentMain.sendChatMessage(message, isDanmaku);
                this.value = '';
                console.log('✓ Message sent successfully');
              } catch (error) {
                console.error('Error sending message:', error);
                debugConnection();
                alert('Error sending message: ' + error.message);
              }
            }
          }
        });
        
        // Hide autocomplete when clicking outside
        document.addEventListener('click', function(e) {
          if (window.commandAutocomplete.menuElement && 
              !window.commandAutocomplete.menuElement.contains(e.target) && 
              e.target !== chatline) {
            hideAutocompleteMenu();
          }
        });
      }

      // Handle emote buttons
      if (smilesbtn) {
        smilesbtn.addEventListener('click', function () {
          toggleEmotePanel('smiles-wrap');
        });
      }

      if (ffzbtn) {
        ffzbtn.addEventListener('click', function () {
          toggleEmotePanel('ffz-wrap');
        });
      }

      if (seventvbtn) {
        seventvbtn.addEventListener('click', function () {
          toggleEmotePanel('seventv-wrap');
        });
      }

      // Handle emote search inputs
      setupEmoteSearch();
      
      // Setup infinite scrolling
      setupInfiniteScroll();
    }

    function setupEmoteSearch() {
      // App emotes search
      const smilesSearch = document.getElementById('smiles-search');
      if (smilesSearch) {
        smilesSearch.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            if (window.parentMain && window.parentMain.searchPopoutEmotes) {
              window.parentMain.searchPopoutEmotes('smiles', this.value);
            }
          }
        });
        smilesSearch.addEventListener('input', function(e) {
          if (window.parentMain && window.parentMain.searchPopoutEmotes) {
            window.parentMain.searchPopoutEmotes('smiles', this.value);
          }
        });
      }

      // FFZ emotes search
      const ffzSearch = document.getElementById('ffz-search');
      if (ffzSearch) {
        ffzSearch.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            if (window.parentMain && window.parentMain.searchPopoutEmotes) {
              window.parentMain.searchPopoutEmotes('ffz', this.value);
            }
          }
        });
      }

      // 7TV emotes search
      const seventvSearch = document.getElementById('seventv-search');
      if (seventvSearch) {
        seventvSearch.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            if (window.parentMain && window.parentMain.searchPopoutEmotes) {
              window.parentMain.searchPopoutEmotes('seventv', this.value);
            }
          }
        });
      }
    }

    // Infinite scroll detection with ResizeObserver and timing controls like main chat
    function setupInfiniteScroll() {
      setupGridInfiniteScroll('ffz-list', 'ffz');
      setupGridInfiniteScroll('seventv-list', 'seventv');
    }

    function setupGridInfiniteScroll(gridId, emoteType) {
      const grid = document.getElementById(gridId);
      if (!grid) return;

      let scrollTimeout = 0;
      let isResizing = false;

      // Helper function to check if all emotes are visible and auto-load if needed
      function checkVisibilityAndAutoLoad(depth = 0) {
        const state = window.emoteState[emoteType];
        if (!state || state.isLoading || !state.hasMore || isResizing) return;

        // Safety limit to prevent infinite recursion
        if (depth > 10) {
          console.log('Reached max auto-load depth for', emoteType, 'emotes');
          return;
        }

        const scrollHeight = grid.scrollHeight;
        const clientHeight = grid.clientHeight;

        // If all content is visible (no scrollbar), load more emotes
        if (scrollHeight <= clientHeight && scrollHeight > 0 && clientHeight > 0) {
          console.log('Auto-loading more', emoteType, 'emotes via visibility check (depth:', depth, ')');
          state.autoLoadDepth = depth + 1;
          
          if (emoteType === 'ffz') {
            loadMoreFFZEmotes();
          } else if (emoteType === 'seventv') {
            loadMore7TVEmotes();
          }
          
          // Schedule another check after a short delay to continue loading if needed
          setTimeout(() => {
            checkVisibilityAndAutoLoad(depth + 1);
          }, 300);
        }
      }

      // Add ResizeObserver to detect layout changes
      if (window.ResizeObserver) {
        const resizeObserver = new ResizeObserver((entries, observer) => {
          isResizing = true;
          if (scrollTimeout !== 0) {
            clearTimeout(scrollTimeout);
          }
          scrollTimeout = setTimeout(() => {
            isResizing = false;
            scrollTimeout = 0;
            // Check if we need to auto-load after resize
            checkVisibilityAndAutoLoad();
          }, 100);
        });
        resizeObserver.observe(grid);
      }

      // Add scroll event listener for when user scrolls near bottom
      grid.addEventListener('scroll', function() {
        if (isResizing) return;
        
        const scrollTop = this.scrollTop;
        const scrollHeight = this.scrollHeight;
        const clientHeight = this.clientHeight;
        
        // Trigger load more when 90% scrolled
        if (scrollTop + clientHeight >= scrollHeight * 0.9) {
          if (emoteType === 'ffz') {
            loadMoreFFZEmotes();
          } else if (emoteType === 'seventv') {
            loadMore7TVEmotes();
          }
        }
      });

      // Initial check for visibility
      setTimeout(checkVisibilityAndAutoLoad, 100);
    }

    function loadMoreFFZEmotes() {
      if (!window.emoteState.ffz.hasMore || window.emoteState.ffz.isLoading) return;
      if (!window.parentMain || !window.parentMain.loadMoreFFZEmotesForPopout) return;

      // Prevent rapid successive calls
      const now = Date.now();
      if (now - window.emoteState.ffz.lastLoadTime < 100) return;
      
      window.emoteState.ffz.isLoading = true;
      window.emoteState.ffz.lastLoadTime = now;
      window.emoteState.ffz.currentPage++;
      window.parentMain.loadMoreFFZEmotesForPopout(window.emoteState.ffz.currentPage);
      
      // Set up a post-load callback after a reasonable delay
      setTimeout(() => {
        if (window.emoteState.ffz.isLoading) {
          // If still loading after 3 seconds, consider it done
          window.emoteState.ffz.isLoading = false;
        }
        // Trigger another visibility check
        const grid = document.getElementById('ffz-list');
        if (grid) {
          const scrollHeight = grid.scrollHeight;
          const clientHeight = grid.clientHeight;
          if (scrollHeight <= clientHeight && scrollHeight > 0 && clientHeight > 0 && window.emoteState.ffz.hasMore) {
            setTimeout(() => loadMoreFFZEmotes(), 200);
          }
        }
      }, 1000);
    }

    function loadMore7TVEmotes() {
      if (!window.emoteState.seventv.hasMore || window.emoteState.seventv.isLoading) return;
      if (!window.parentMain || !window.parentMain.loadMore7TVEmotesForPopout) return;

      // Prevent rapid successive calls
      const now = Date.now();
      if (now - window.emoteState.seventv.lastLoadTime < 100) return;
      
      window.emoteState.seventv.isLoading = true;
      window.emoteState.seventv.lastLoadTime = now;
      window.emoteState.seventv.currentPage++;
      window.parentMain.loadMore7TVEmotesForPopout(window.emoteState.seventv.currentPage);
      
      // Set up a post-load callback after a reasonable delay
      setTimeout(() => {
        if (window.emoteState.seventv.isLoading) {
          // If still loading after 3 seconds, consider it done
          window.emoteState.seventv.isLoading = false;
        }
        // Trigger another visibility check
        const grid = document.getElementById('seventv-list');
        if (grid) {
          const scrollHeight = grid.scrollHeight;
          const clientHeight = grid.clientHeight;
          if (scrollHeight <= clientHeight && scrollHeight > 0 && clientHeight > 0 && window.emoteState.seventv.hasMore) {
            setTimeout(() => loadMore7TVEmotes(), 200);
          }
        }
      }, 1000);
    }


    function toggleEmotePanel(panelId) {
      const panels = document.querySelector('.emote-panels');
      const panel = document.getElementById(panelId);
      const allPanels = panels.querySelectorAll('.emote-panel');

      allPanels.forEach(p => {
        if (p.id !== panelId) {
          p.style.display = 'none';
        }
      });

      if (panel.style.display === 'none') {
        panel.style.display = 'block';
        panels.style.display = 'block';
        if (window.parentMain) {
          window.parentMain.loadEmotesForPopout(panelId);
          
          // Set up multiple delayed checks to ensure emotes fill the container
          const emoteType = panelId === 'ffz-wrap' ? 'ffz' : (panelId === 'seventv-wrap' ? 'seventv' : null);
          if (emoteType) {
            // Reset state for new panel
            window.emoteState[emoteType].autoLoadDepth = 0;
            
            // Multiple timed checks to ensure container gets filled
            setTimeout(() => triggerVisibilityCheck(emoteType), 300);
            setTimeout(() => triggerVisibilityCheck(emoteType), 800);
            setTimeout(() => triggerVisibilityCheck(emoteType), 1500);
            setTimeout(() => triggerVisibilityCheck(emoteType), 2500);
          }
        }
      } else {
        panel.style.display = 'none';
        panels.style.display = 'none';
      }
    }
    
    function triggerVisibilityCheck(emoteType) {
      const gridId = emoteType === 'ffz' ? 'ffz-list' : 'seventv-list';
      const grid = document.getElementById(gridId);
      if (!grid) return;
      
      const state = window.emoteState[emoteType];
      if (!state || state.isLoading || !state.hasMore) return;

      const scrollHeight = grid.scrollHeight;
      const clientHeight = grid.clientHeight;
      
      console.log(`Visibility check for ${emoteType}: scrollHeight=${scrollHeight}, clientHeight=${clientHeight}`);

      // If all content is visible (no scrollbar), trigger loading
      if (scrollHeight <= clientHeight && scrollHeight > 0 && clientHeight > 0) {
        console.log(`Triggering auto-load for ${emoteType} - container not scrollable`);
        if (emoteType === 'ffz') {
          loadMoreFFZEmotes();
        } else if (emoteType === 'seventv') {
          loadMore7TVEmotes();
        }
      }
    }

    function addMessage(messageHtml) {
      const messagebuffer = document.getElementById('messagebuffer');
      if (messagebuffer) {
        messagebuffer.insertAdjacentHTML('afterbegin', messageHtml);
        // Keep only the last 200 messages
        while (messagebuffer.children.length > 200) {
          messagebuffer.removeChild(messagebuffer.lastChild);
        }
      }
    }
    
    // Callback function for when emotes finish loading
    window.onEmotesLoaded = function(emoteType, hasMore) {
      console.log('Emotes loaded callback:', emoteType, 'hasMore:', hasMore);
      const state = window.emoteState[emoteType];
      if (state) {
        state.isLoading = false;
        state.hasMore = hasMore;
        
        // Trigger a visibility check after a short delay to allow DOM to update
        setTimeout(() => {
          triggerVisibilityCheck(emoteType);
        }, 100);
      }
    };
    
    // Callback function for when emote loading fails
    window.onEmoteLoadError = function(emoteType, error) {
      console.log('Emotes load error callback:', emoteType, error);
      const state = window.emoteState[emoteType];
      if (state) {
        state.isLoading = false;
        // Don't retry immediately on error, wait for user action
      }
    };

    // Handle window closing
    window.addEventListener('beforeunload', function () {
      if (window.parentMain && window.parentMain.onPopoutClosed) {
        window.parentMain.onPopoutClosed();
      }
    });

    // Initialize when loaded
    document.addEventListener('DOMContentLoaded', function () {
      console.log('Popout DOMContentLoaded');

      // Give the parent window a moment to set up the connection
      setTimeout(function () {
        debugConnection();

        // Try to establish connection
        if (!establishParentConnection()) {
          console.log('Initial connection failed, will retry on first interaction');
        }

        initializePopoutChat();
      }, 100);
    });

    // Also try on window load as fallback
    window.addEventListener('load', function () {
      console.log('Popout window loaded');

      // Another attempt to establish connection
      setTimeout(function () {
        debugConnection();
        establishParentConnection();
      }, 200);
    });
  </script>
</body>

</html>